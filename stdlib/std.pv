// === println overloads ===


fn println(x: i32) -> void {
    putln x;
}

fn println(x: i64) -> void {
    putln x;
}

fn println(x: f32) -> void {
    putln x;
}

fn println(x: f64) -> void {
    putln x;
}

fn println(x: str) -> void {
    putln x;
}

fn println(x: bool) -> void {
    putln x;
}

// === print overloads ===

fn print(x: i32) -> void {
    put x;
}

fn print(x: i64) -> void {
    put x;
}

fn print(x: f32) -> void {
    put x;
}

fn print(x: f64) -> void {
    put x;
}

fn print(x: str) -> void {
    put x;
}

fn print(x: bool) -> void {
    put x;
}


// === to_str overloads ===


fn to_str(x: i32) -> str {
    return "" + x;
}

fn to_str(x: i64) -> str {
    return "" + x;
}

fn to_str(x: f32) -> str {
    return "" + x;
}

fn to_str(x: f64) -> str {
    return "" + x;
}

fn to_str(x: bool) -> str {
    return "" + x;
}

fn to_str(x: str) -> str {
    return x;
}


// === string utils ===


fn split(s: str, delimiter: str) -> [str] {
    let result: [str] = [0;""];

    let current: str = "";

    for (i := 0; i<len s; i++) {
        if (s[i]==delimiter) {
            push result current;
            current = "";
        } else {
            current = current + s[i];
        }
    }

    push result current;

    return result;
}


// === random ===


fn cast_to_int(arr: [bool]) -> i32 {
    let result: i32 = 0i32;
    let exp: i32 = 0;
    for (i:=1; i<=len arr; i++) {
        if (arr[(len arr) - i]) {
            result = result + 2**exp;
        }
        exp = exp + 1;
    }

    return result;
}

fn rand_i32(max: i32) -> i32 {
    let arr: [bool] = [31;true];
    for (i := 0; i<31; i++) {
        arr[i] = maybe;
    }
    return arr.cast_to_int() % max;
}
